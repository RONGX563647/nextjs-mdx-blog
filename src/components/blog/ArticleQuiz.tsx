'use client'

import { useState, useEffect, useRef } from 'react'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Loader2, CheckCircle2, XCircle, HelpCircle, RefreshCw, BookOpen, Sparkles } from 'lucide-react'
import ReactMarkdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import rehypeHighlight from 'rehype-highlight'

interface Question {
  id: number
  question: string
  options: string[]
  correctAnswer: string
  explanation: string
}

interface QuizData {
  questions: Question[]
}

interface ArticleQuizProps {
  articleContent: string
  articleTitle: string
}

// 用于存储已生成测试的文章标识
const getArticleKey = (title: string) => `quiz_generated_${title}`

export function ArticleQuiz({ articleContent, articleTitle }: ArticleQuizProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [quizData, setQuizData] = useState<QuizData | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [userAnswers, setUserAnswers] = useState<Record<number, string>>({})
  const [showResults, setShowResults] = useState(false)
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0)
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false)
  const [isVisible, setIsVisible] = useState(false)
  const quizRef = useRef<HTMLDivElement>(null)
  const hasRequestedRef = useRef(false)
  const contentRef = useRef(articleContent)

  // 保存内容到 ref，避免依赖数组变化
  useEffect(() => {
    if (articleContent && articleContent.length > 100) {
      contentRef.current = articleContent
    }
  }, [articleContent])

  // 页面加载时立即自动生成（只生成一次）
  useEffect(() => {
    // 只在客户端执行
    if (typeof window === 'undefined') return
    
    // 确保文章内容已加载且未请求过
    if (!articleTitle) return
    if (hasRequestedRef.current) return
    if (quizData) return
    if (isLoading) return
    
    // 检查是否已经为这篇文章生成过测试
    const articleKey = getArticleKey(articleTitle)
    const hasGeneratedBefore = sessionStorage.getItem(articleKey)
    
    if (hasGeneratedBefore) return
    
    hasRequestedRef.current = true
    
    // 立即自动生成测试题
    generateQuiz(true)
    // 标记已生成
    sessionStorage.setItem(articleKey, 'true')
    // 只依赖 articleTitle，避免 articleContent 变化导致重新触发
  }, [articleTitle])

  const generateQuiz = async (auto = false) => {
    if (isLoading || quizData) return
    
    const content = contentRef.current
    if (!content || content.length < 100) {
      setError('文章内容未准备好，请刷新页面重试')
      return
    }
    
    setIsLoading(true)
    setError(null)
    if (!auto) {
      setQuizData(null)
      setUserAnswers({})
      setShowResults(false)
      setCurrentQuestionIndex(0)
    }

    try {
      const response = await fetch('/api/quiz', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ content }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || '生成测试题失败')
      }

      const data = await response.json()
      setQuizData(data)
      setIsOpen(true)
      setHasAutoGenerated(true)
    } catch (err) {
      setError(err instanceof Error ? err.message : '生成测试题失败，请稍后重试')
      // 重置请求标记，允许重试
      hasRequestedRef.current = false
    } finally {
      setIsLoading(false)
    }
  }

  const handleAnswerSelect = (questionId: number, answer: string) => {
    if (showResults) return
    setUserAnswers((prev) => ({ ...prev, [questionId]: answer }))
  }

  const handleSubmit = () => {
    setShowResults(true)
  }

  const handleRetry = () => {
    setShowResults(false)
    setUserAnswers({})
    setCurrentQuestionIndex(0)
  }

  const handleRegenerate = () => {
    setQuizData(null)
    setUserAnswers({})
    setShowResults(false)
    setCurrentQuestionIndex(0)
    setHasAutoGenerated(false)
    hasRequestedRef.current = false
    generateQuiz(false)
  }

  const getScore = () => {
    if (!quizData) return 0
    let correct = 0
    quizData.questions.forEach((q) => {
      if (userAnswers[q.id] === q.correctAnswer) {
        correct++
      }
    })
    return correct
  }

  const currentQuestion = quizData?.questions[currentQuestionIndex]
  const isLastQuestion = currentQuestionIndex === (quizData?.questions.length || 0) - 1
  const allAnswered = quizData?.questions.every((q) => userAnswers[q.id])

  return (
    <div ref={quizRef} className="mt-8">
      {!isOpen ? (
        <Card className="border-dashed border-2 border-primary/30 bg-primary/5">
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-primary/10 rounded-lg relative">
                  <HelpCircle className="h-5 w-5 text-primary" />
                  {isLoading && (
                    <span className="absolute -top-1 -right-1 flex h-3 w-3">
                      <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                      <span className="relative inline-flex rounded-full h-3 w-3 bg-primary"></span>
                    </span>
                  )}
                </div>
                <div>
                  <h3 className="font-semibold text-lg flex items-center gap-2">
                    知识点测试
                    {isLoading && <Sparkles className="h-4 w-4 text-primary animate-pulse" />}
                  </h3>
                  <p className="text-sm text-muted-foreground">
                    {isLoading 
                      ? 'AI正在根据文章内容生成测试题，请稍候...' 
                      : '读完文章了？来测试一下你对知识点的掌握程度吧！'}
                  </p>
                </div>
              </div>
              <Button
                onClick={() => generateQuiz(false)}
                disabled={isLoading}
                className="gap-2"
              >
                {isLoading ? (
                  <>
                    <Loader2 className="h-4 w-4 animate-spin" />
                    生成中...
                  </>
                ) : (
                  <>
                    <BookOpen className="h-4 w-4" />
                    开始测试
                  </>
                )}
              </Button>
            </div>
            {error && (
              <div className="mt-4 p-3 bg-destructive/10 text-destructive rounded-md text-sm">
                {error}
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={() => generateQuiz(false)} 
                  className="ml-2"
                >
                  重试
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      ) : (
        <Card className="border-primary/20">
          <CardHeader className="pb-4">
            <div className="flex items-center justify-between">
              <CardTitle className="text-xl flex items-center gap-2">
                <HelpCircle className="h-5 w-5 text-primary" />
                知识点测试
                <span className="text-xs font-normal text-muted-foreground bg-primary/10 px-2 py-1 rounded-full">
                  AI生成
                </span>
              </CardTitle>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleRegenerate}
                  disabled={isLoading}
                  className="gap-1"
                >
                  <RefreshCw className="h-3 w-3" />
                  重新生成
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setIsOpen(false)}
                >
                  收起
                </Button>
              </div>
            </div>
            {showResults && (
              <div className="mt-2 p-3 bg-primary/10 rounded-lg">
                <p className="font-medium text-center">
                  得分：{getScore()} / {quizData?.questions.length}
                  <span className="text-sm text-muted-foreground ml-2">
                    ({Math.round((getScore() / (quizData?.questions.length || 1)) * 100)}%)
                  </span>
                </p>
              </div>
            )}
          </CardHeader>
          <CardContent>
            {quizData && (
              <>
                {/* 题目进度指示器 */}
                <div className="flex gap-1 mb-4">
                  {quizData.questions.map((q, idx) => (
                    <button
                      key={q.id}
                      onClick={() => setCurrentQuestionIndex(idx)}
                      className={`flex-1 h-2 rounded-full transition-all ${
                        idx === currentQuestionIndex
                          ? 'bg-primary'
                          : userAnswers[q.id]
                          ? showResults
                            ? userAnswers[q.id] === q.correctAnswer
                              ? 'bg-green-500'
                              : 'bg-red-500'
                            : 'bg-primary/50'
                          : 'bg-muted'
                      }`}
                    />
                  ))}
                </div>

                {/* 当前题目 */}
                {currentQuestion && (
                  <div className="space-y-4">
                    <div className="flex items-center gap-2 text-sm text-muted-foreground mb-2">
                      <span>题目 {currentQuestionIndex + 1} / {quizData.questions.length}</span>
                      {showResults && (
                        <span className="flex items-center gap-1">
                          {userAnswers[currentQuestion.id] === currentQuestion.correctAnswer ? (
                            <CheckCircle2 className="h-4 w-4 text-green-500" />
                          ) : (
                            <XCircle className="h-4 w-4 text-red-500" />
                          )}
                          {userAnswers[currentQuestion.id] === currentQuestion.correctAnswer ? '正确' : '错误'}
                        </span>
                      )}
                    </div>

                    <div className="prose dark:prose-invert max-w-none">
                      <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        rehypePlugins={[rehypeHighlight]}
                      >
                        {currentQuestion.question}
                      </ReactMarkdown>
                    </div>

                    <div className="space-y-2">
                      {currentQuestion.options.map((option, idx) => {
                        const optionLetter = option.charAt(0)
                        const isSelected = userAnswers[currentQuestion.id] === optionLetter
                        const isCorrect = optionLetter === currentQuestion.correctAnswer
                        const showCorrectness = showResults && (isSelected || isCorrect)

                        return (
                          <button
                            key={idx}
                            onClick={() => handleAnswerSelect(currentQuestion.id, optionLetter)}
                            disabled={showResults}
                            className={`w-full text-left p-4 rounded-lg border-2 transition-all ${
                              showCorrectness
                                ? isCorrect
                                  ? 'border-green-500 bg-green-500/10'
                                  : isSelected
                                  ? 'border-red-500 bg-red-500/10'
                                  : 'border-muted bg-muted/50'
                                : isSelected
                                ? 'border-primary bg-primary/10'
                                : 'border-muted hover:border-primary/50 hover:bg-muted/50'
                            }`}
                          >
                            <div className="flex items-start gap-3">
                              <span
                                className={`flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center text-sm font-medium ${
                                  showCorrectness
                                    ? isCorrect
                                      ? 'bg-green-500 text-white'
                                      : isSelected
                                      ? 'bg-red-500 text-white'
                                      : 'bg-muted text-muted-foreground'
                                    : isSelected
                                    ? 'bg-primary text-primary-foreground'
                                    : 'bg-muted text-muted-foreground'
                                }`}
                              >
                                {optionLetter}
                              </span>
                              <span className="flex-1">{option.slice(3)}</span>
                              {showCorrectness && isCorrect && (
                                <CheckCircle2 className="h-5 w-5 text-green-500 flex-shrink-0" />
                              )}
                              {showCorrectness && isSelected && !isCorrect && (
                                <XCircle className="h-5 w-5 text-red-500 flex-shrink-0" />
                              )}
                            </div>
                          </button>
                        )
                      })}
                    </div>

                    {/* 答案解析 */}
                    {showResults && (
                      <div className="mt-4 p-4 bg-muted rounded-lg">
                        <p className="font-medium mb-2 flex items-center gap-2">
                          <BookOpen className="h-4 w-4" />
                          答案解析
                        </p>
                        <div className="prose dark:prose-invert max-w-none text-sm">
                          <ReactMarkdown
                            remarkPlugins={[remarkGfm]}
                            rehypePlugins={[rehypeHighlight]}
                          >
                            {currentQuestion.explanation}
                          </ReactMarkdown>
                        </div>
                      </div>
                    )}

                    {/* 导航按钮 */}
                    <div className="flex items-center justify-between pt-4">
                      <Button
                        variant="outline"
                        onClick={() => setCurrentQuestionIndex((prev) => Math.max(0, prev - 1))}
                        disabled={currentQuestionIndex === 0}
                      >
                        上一题
                      </Button>

                      {!showResults ? (
                        isLastQuestion ? (
                          <Button
                            onClick={handleSubmit}
                            disabled={!allAnswered}
                            className="gap-2"
                          >
                            <CheckCircle2 className="h-4 w-4" />
                            提交答案
                          </Button>
                        ) : (
                          <Button
                            onClick={() => setCurrentQuestionIndex((prev) => prev + 1)}
                            disabled={!userAnswers[currentQuestion.id]}
                          >
                            下一题
                          </Button>
                        )
                      ) : (
                        isLastQuestion ? (
                          <Button onClick={handleRetry} variant="outline" className="gap-2">
                            <RefreshCw className="h-4 w-4" />
                            重新作答
                          </Button>
                        ) : (
                          <Button
                            onClick={() => setCurrentQuestionIndex((prev) => prev + 1)}
                          >
                            下一题
                          </Button>
                        )
                      )}
                    </div>
                  </div>
                )}
              </>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  )
}
