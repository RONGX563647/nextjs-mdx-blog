# 微服务网络通信模式

## 一、问题引入：分布式系统的通信挑战

### 1.1 真实案例：服务网格化改造

```
场景：单体应用拆分为50+微服务，通信复杂度激增
问题：服务间调用链路长，故障难以定位

挑战：
┌─────────────────────────────────────────────────────────────┐
│ 通信复杂度：                                                 │
│ - 服务间调用关系复杂，形成网状结构                           │
│ - 版本兼容性问题                                             │
│ - 跨语言通信困难                                             │
├─────────────────────────────────────────────────────────────┤
│ 可靠性问题：                                                 │
│ - 网络分区导致服务不可用                                     │
│ - 级联故障风险                                               │
│ - 超时和重试策略难以统一                                     │
├─────────────────────────────────────────────────────────────┤
│ 可观测性问题：                                               │
│ - 调用链路追踪困难                                           │
│ - 性能瓶颈难以定位                                           │
│ - 故障排查耗时长                                             │
└─────────────────────────────────────────────────────────────┘
```

## 二、同步通信模式

### 2.1 RESTful HTTP

```java
/**
 * RESTful服务调用
 */
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public Order getOrder(Long orderId) {
        // 同步HTTP调用
        ResponseEntity<Order> response = restTemplate.getForEntity(
            "http://order-service/orders/{id}",
            Order.class,
            orderId
        );
        return response.getBody();
    }
}
```

### 2.2 gRPC高性能RPC

```protobuf
// 定义服务
service OrderService {
    rpc GetOrder(GetOrderRequest) returns (Order);
    rpc CreateOrder(CreateOrderRequest) returns (Order);
}

message GetOrderRequest {
    int64 order_id = 1;
}

message Order {
    int64 order_id = 1;
    string status = 2;
    double amount = 3;
}
```

```java
/**
 * gRPC服务实现
 */
@GrpcService
public class OrderGrpcService extends OrderServiceGrpc.OrderServiceImplBase {
    
    @Override
    public void getOrder(GetOrderRequest request, StreamObserver<Order> responseObserver) {
        Order order = orderRepository.findById(request.getOrderId());
        responseObserver.onNext(order);
        responseObserver.onCompleted();
    }
}
```

## 三、异步通信模式

### 3.1 消息队列

```java
/**
 * 事件驱动架构
 */
@Service
public class OrderEventPublisher {
    
    @Autowired
    private ApplicationEventPublisher publisher;
    
    public void publishOrderCreated(Order order) {
        // 发布异步事件
        publisher.publishEvent(new OrderCreatedEvent(order));
    }
}

@Component
public class OrderEventListener {
    
    @EventListener
    @Async
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 异步处理：发送通知
        notificationService.sendOrderConfirmation(event.getOrder());
    }
}
```

### 3.2 Saga分布式事务

```java
/**
 * Saga模式实现
 */
@Service
public class OrderSaga {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @SagaStart
    public void createOrder(CreateOrderRequest request) {
        try {
            // 步骤1：创建订单
            Order order = orderService.createOrder(request);
            
            // 步骤2：扣减库存
            inventoryService.deductStock(request.getItems());
            
            // 步骤3：处理支付
            paymentService.processPayment(order);
            
        } catch (Exception e) {
            // 触发补偿
            compensateOrder(request);
        }
    }
    
    @Compensate
    public void compensateOrder(CreateOrderRequest request) {
        // 补偿逻辑
        inventoryService.restoreStock(request.getItems());
    }
}
```

## 四、服务发现与负载均衡

### 4.1 Eureka服务注册

```java
/**
 * Eureka客户端配置
 */
@SpringBootApplication
@EnableDiscoveryClient
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}

@Service
public class ServiceDiscovery {
    
    @Autowired
    private LoadBalancerClient loadBalancer;
    
    public String getServiceUrl(String serviceId) {
        ServiceInstance instance = loadBalancer.choose(serviceId);
        return instance.getUri().toString();
    }
}
```

### 4.2 Ribbon负载均衡

```java
/**
 * 自定义负载均衡策略
 */
@Configuration
public class RibbonConfig {
    
    @Bean
    public IRule ribbonRule() {
        // 权重响应时间策略
        return new WeightedResponseTimeRule();
    }
}
```

## 五、服务网格（Service Mesh）

### 5.1 Istio架构

```
Istio核心组件：
┌──────────────────────────────────────────────────────────────┐
│                                                              │
│  数据平面（Envoy Sidecar）                                   │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐                 │
│  │ Service │◄──►│  Envoy  │◄──►│ Service │                 │
│  │    A    │    │ Sidecar │    │    B    │                 │
│  └─────────┘    └────┬────┘    └─────────┘                 │
│                      │                                       │
│  控制平面（Istiod）   │                                       │
│  ┌───────────────────┼───────────────────┐                  │
│  │ Pilot（流量管理）  │ Citadel（安全）   │                  │
│  │ Galley（配置）     │                   │                  │
│  └───────────────────┴───────────────────┘                  │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 5.2 Istio流量管理

```yaml
# VirtualService配置
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: order-service
spec:
  hosts:
    - order-service
  http:
    - route:
        - destination:
            host: order-service
            subset: v1
          weight: 90
        - destination:
            host: order-service
            subset: v2
          weight: 10
      timeout: 5s
      retries:
        attempts: 3
        perTryTimeout: 2s
```

## 六、通信模式选型

```
选型指南：
┌──────────────────────────────────────────────────────────────┐
│                                                              │
│  场景              │ 推荐方案                                │
│  ─────────────────┼───────────────────────────────────────  │
│  实时查询          │ REST/gRPC同步调用                       │
│  异步处理          │ 消息队列（RabbitMQ/Kafka）              │
│  实时推送          │ WebSocket/SSE                           │
│  大数据流          │ gRPC Streaming                          │
│  跨语言通信        │ gRPC/HTTP REST                          │
│  高性能内部通信    │ gRPC                                    │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

**系列上一篇**：[长连接与连接池设计](08长连接与连接池设计.md)

**系列下一篇**：[API网关设计与实现](10API网关设计与实现.md)
