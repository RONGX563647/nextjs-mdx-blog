# 网络安全防护体系

## 一、问题引入：安全事件的代价

### 1.1 真实案例：数据泄露事件

```
场景：2024年某平台遭遇APT攻击
损失：5000万用户数据泄露，罚款2亿，股价暴跌30%

攻击路径：
┌─────────────────────────────────────────────────────────────┐
│ 1. 信息收集                                                 │
│    - 扫描暴露面，发现未授权API                              │
│    - 社工获取员工凭据                                       │
├─────────────────────────────────────────────────────────────┤
│ 2. 初始入侵                                                 │
│    - 利用SQL注入获取数据库访问                              │
│    - 横向移动至内网                                         │
├─────────────────────────────────────────────────────────────┤
│ 3. 权限提升                                                 │
│    - 利用提权漏洞获取管理员权限                             │
│    - 安装后门持久化                                         │
├─────────────────────────────────────────────────────────────┤
│ 4. 数据窃取                                                 │
│    - 批量导出用户数据                                       │
│    - 通过DNS隧道外传                                        │
├─────────────────────────────────────────────────────────────┤
│ 5. 事后复盘                                                 │
│    - WAF规则过时，未拦截新型注入                            │
│    - 内网缺乏微隔离                                         │
│    - 日志不完整，无法追溯                                   │
│    - 缺乏数据分类分级                                       │
└─────────────────────────────────────────────────────────────┘
```

## 二、纵深防御体系

```
纵深防御架构：
┌──────────────────────────────────────────────────────────────┐
│ 边界层：WAF/CDN/DDoS防护                                     │
├──────────────────────────────────────────────────────────────┤
│ 接入层：API网关/身份认证/限流                                │
├──────────────────────────────────────────────────────────────┤
│ 应用层：RASP/代码审计/输入验证                               │
├──────────────────────────────────────────────────────────────┤
│ 服务层：mTLS/服务网格/零信任                                 │
├──────────────────────────────────────────────────────────────┤
│ 数据层：加密/脱敏/访问控制/审计                              │
├──────────────────────────────────────────────────────────────┤
│ 基础设施：漏洞管理/基线检查/监控告警                         │
└──────────────────────────────────────────────────────────────┘
```

## 三、Web应用防火墙（WAF）

### 3.1 ModSecurity规则配置

```nginx
# Nginx + ModSecurity配置
modsecurity on;
modsecurity_rules_file /etc/nginx/modsecurity/modsecurity.conf;

# 自定义规则
SecRuleEngine On
SecRequestBodyAccess On
SecResponseBodyAccess On

# SQL注入防护
SecRule REQUEST_COOKIES|REQUEST_COOKIES_NAMES|REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \
    "@rx (?i:(?:select\s*\*\s*from|(?:delete|drop|truncate)\s+table|union(?:\s+all)?\s*select|insert\s+into\s+.*\s*values))" \
    "id:942100,phase:2,deny,status:403,msg:'SQL Injection Attack Detected'"

# XSS防护
SecRule REQUEST_COOKIES|REQUEST_COOKIES_NAMES|REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \
    "@rx (?i:(?:<script[^>]*>[\\s\\S]*?</script>|<javascript:[^>]*>|<iframe[^>]*>[\\s\\S]*?</iframe>))" \
    "id:941100,phase:2,deny,status:403,msg:'XSS Attack Detected'"
```

### 3.2 阿里云WAF配置

```yaml
# Terraform配置
resource "alicloud_waf_domain" "example" {
  domain_name = "example.com"
  
  # 防护模式
  defense_mode = "block"  # block:拦截, observe:观察
  
  # CC防护
  cc_rules {
    name = "api_limit"
    mode = "block"
    count = 1000
    interval = 60
  }
  
  # 防篡改
  anti_tamper {
    uri = "/api/config"
  }
}
```

## 四、零信任安全架构

### 4.1 零信任核心原则

```
永不信任，始终验证：
1. 不信任任何网络位置（内网/外网一视同仁）
2. 最小权限原则
3. 持续验证身份和设备状态
4. 假设 breach（已泄露）设计
```

### 4.2 Istio mTLS实现

```yaml
# PeerAuthentication配置
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT  # 强制mTLS

---
# AuthorizationPolicy配置
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: order-service-policy
  namespace: default
spec:
  selector:
    matchLabels:
      app: order-service
  action: ALLOW
  rules:
    - from:
        - source:
            principals: ["cluster.local/ns/default/sa/api-gateway"]
      to:
        - operation:
            methods: ["GET", "POST"]
            paths: ["/api/orders/*"]
```

## 五、数据安全防护

### 5.1 敏感数据分类分级

```
数据分级：
┌──────────────────────────────────────────────────────────────┐
│ L1 公开数据：产品信息、公司介绍                              │
├──────────────────────────────────────────────────────────────┤
│ L2 内部数据：员工通讯录、内部文档                            │
├──────────────────────────────────────────────────────────────┤
│ L3 敏感数据：用户手机号、交易记录                            │
├──────────────────────────────────────────────────────────────┤
│ L4 机密数据：密码、密钥、身份证号                            │
├──────────────────────────────────────────────────────────────┤
│ L5 绝密数据：核心算法、商业机密                              │
└──────────────────────────────────────────────────────────────┘
```

### 5.2 数据脱敏实现

```java
/**
 * 数据脱敏工具
 */
@Component
public class DataMasker {

    /**
     * 手机号脱敏
     */
    public String maskPhone(String phone) {
        if (StringUtils.isEmpty(phone) || phone.length() != 11) {
            return phone;
        }
        return phone.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
    }

    /**
     * 身份证号脱敏
     */
    public String maskIdCard(String idCard) {
        if (StringUtils.isEmpty(idCard) || idCard.length() != 18) {
            return idCard;
        }
        return idCard.replaceAll("(\\d{6})\\d{8}(\\d{4})", "$1********$2");
    }

    /**
     * 银行卡号脱敏
     */
    public String maskBankCard(String cardNo) {
        if (StringUtils.isEmpty(cardNo) || cardNo.length() < 8) {
            return cardNo;
        }
        return cardNo.replaceAll("(\\d{4})\\d+(\\d{4})", "$1 **** **** $2");
    }

    /**
     * 姓名脱敏
     */
    public String maskName(String name) {
        if (StringUtils.isEmpty(name) || name.length() < 2) {
            return name;
        }
        return name.charAt(0) + "*".repeat(name.length() - 1);
    }
}

/**
 * MyBatis脱敏拦截器
 */
@Intercepts({
    @Signature(type = ResultSetHandler.class, method = "handleResultSets", args = {Statement.class})
})
@Component
public class MaskingInterceptor implements Interceptor {

    @Autowired
    private DataMasker dataMasker;

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Object result = invocation.proceed();
        
        if (result instanceof List) {
            for (Object item : (List<?>) result) {
                maskSensitiveFields(item);
            }
        }
        
        return result;
    }

    private void maskSensitiveFields(Object obj) {
        // 反射处理@Mask注解字段
        for (Field field : obj.getClass().getDeclaredFields()) {
            Mask mask = field.getAnnotation(Mask.class);
            if (mask != null) {
                field.setAccessible(true);
                try {
                    String value = (String) field.get(obj);
                    String masked = applyMask(value, mask.type());
                    field.set(obj, masked);
                } catch (IllegalAccessException e) {
                    log.error("Masking failed", e);
                }
            }
        }
    }
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Mask {
    MaskType type();
}

public enum MaskType {
    PHONE, ID_CARD, BANK_CARD, NAME, EMAIL
}
```

## 六、安全监控与审计

### 6.1 安全日志规范

```java
/**
 * 安全审计日志
 */
@Component
@Slf4j
public class SecurityAuditLogger {

    private static final Logger AUDIT_LOG = LoggerFactory.getLogger("SECURITY_AUDIT");

    /**
     * 记录登录事件
     */
    public void logLogin(String username, boolean success, String ip, String userAgent) {
        AUDIT_LOG.info("[LOGIN] user={}, success={}, ip={}, ua={}",
            username, success, ip, userAgent);
    }

    /**
     * 记录敏感操作
     */
    public void logSensitiveOperation(String operation, String resource, 
                                       String userId, boolean allowed) {
        AUDIT_LOG.info("[SENSITIVE_OP] op={}, resource={}, user={}, allowed={}",
            operation, resource, userId, allowed);
    }

    /**
     * 记录数据访问
     */
    public void logDataAccess(String dataType, String dataId, 
                               String userId, String action) {
        AUDIT_LOG.info("[DATA_ACCESS] type={}, id={}, user={}, action={}",
            dataType, dataId, userId, action);
    }
}
```

### 6.2 异常行为检测

```java
/**
 * 异常登录检测
 */
@Component
public class AnomalyDetector {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * 检测异地登录
     */
    public boolean detectGeoAnomaly(String userId, String currentCity) {
        String key = "login:geo:" + userId;
        String lastCity = redisTemplate.opsForValue().get(key);
        
        if (lastCity != null && !lastCity.equals(currentCity)) {
            // 异地登录告警
            alertService.sendAlert("异地登录", userId, lastCity + " -> " + currentCity);
            return true;
        }
        
        redisTemplate.opsForValue().set(key, currentCity, 30, TimeUnit.DAYS);
        return false;
    }

    /**
     * 检测暴力破解
     */
    public boolean detectBruteForce(String username, String ip) {
        String key = "login:fail:" + ip;
        Long failures = redisTemplate.opsForValue().increment(key);
        
        if (failures == 1) {
            redisTemplate.expire(key, 1, TimeUnit.HOURS);
        }
        
        if (failures > 5) {
            // 封禁IP
            blockIP(ip);
            return true;
        }
        
        return false;
    }
}
```

## 七、安全开发规范

```
安全开发检查清单：
□ 输入验证：所有用户输入必须验证
□ 输出编码：防止XSS攻击
□ SQL参数化：禁止字符串拼接SQL
□ 密码安全：使用bcrypt/Argon2加密
□ 会话管理：JWT过期时间、刷新机制
□ 敏感数据：加密存储、传输加密
□ 错误处理：不泄露系统信息
□ 依赖安全：定期扫描漏洞
□ 日志安全：不记录敏感信息
□ 权限控制：最小权限原则
```

---

**系列上一篇**：[API网关设计与实现](10API网关设计与实现.md)

**系列下一篇**：[混合云网络架构](12混合云网络架构.md)
